<?php
namespace TYPO3\FalWebdav\Dav;

/**
 * This file is part of the TYPO3 CMS project.
 *
 * It is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, either version 2
 * of the License, or any later version.
 *
 * For the full copyright and license information, please read the
 * LICENSE.txt file that was distributed with this source code.
 *
 * The TYPO3 project - inspiring people to share!
 */

include_once __DIR__ . '/../../Resources/Composer/vendor/autoload.php';

use Sabre\DAV\Client;
use Sabre\HTTP;


/**
 * Helper class to circumvent limitations in SabreDAV's support for cURL's certificate verification options.
 */
class WebDavClient extends Client
{

    /**
     * Trigger to enable/disable peer certificate verification
     *
     * @var boolean
     */
    protected $verifyCertificates = true;

    /**
     * The file to write the data to.
     *
     * @var resource
     */
    protected $outputFile = null;


    /**
     * @param boolean $peerVerification
     */
    public function setCertificateVerification($peerVerification)
    {
        $this->verifyCertificates = $peerVerification;
    }

    /**
     * Wrapper for all cUrl functions.
     *
     * @param resource $curlHandle
     *
     * @return array
     */
    protected function curlExec($curlHandle)
    {
        if ($this->verifyCertificates === false) {
            curl_setopt($curlHandle, CURLOPT_SSL_VERIFYPEER, false);
        }
        if ($this->outputFile !== null) {
            // make sure the file is never returned into the default output stream
            curl_setopt($curlHandle, CURLOPT_RETURNTRANSFER, false);
            // don’t return the headers
            curl_setopt($curlHandle, CURLOPT_HEADER, false);
            curl_setopt($curlHandle, CURLOPT_FILE, $this->outputFile);
            curl_setopt($curlHandle, CURLOPT_FOLLOWLOCATION, true);
            $this->outputFile = null;
        } else {
            // set back to default as the cURL handle is not always reset; the file is not used anyways, but cURL
            // still complains about the handle being gone away if we closed the file that was used in an earlier
            // request
            curl_setopt($curlHandle, CURLOPT_FILE, fopen('php://stdout', 'w'));

            // we must use a different order here; setting RETURNTRANSFER before resetting the file handle will let
            // cURL still use the file.
            curl_setopt($curlHandle, CURLOPT_RETURNTRANSFER, true);
        }

        return parent::curlExec($curlHandle);
    }

    function propFind($url, array $properties = null, $depth = 0)
    {
        if ($properties === null) {
            $properties = array(
                '{DAV:}resourcetype',
                '{DAV:}creationdate',
                '{DAV:}getcontentlength',
                '{DAV:}getlastmodified'
            );
        }

        return parent::propFind($url, $properties, $depth); // TODO: Change the autogenerated stub
    }

    /**
     * Reads the given URL’s contents to the given file handle. The handle must be writable, the disk must have enough
     * free space and
     *
     * @param string $url
     * @param resource $fileHandle
     * @param array $headers
     * @return HTTP\ResponseInterface
     */
    public function readUrlToHandle($url, $fileHandle, array $headers = [])
    {
        if (!is_resource($fileHandle)) {
            throw new \InvalidArgumentException('The file handle must be a valid resource');
        }
        $request = new HTTP\Request('GET', $url, $headers);

        // The actual option is set in curlExec(), as we don’t have access to the cURL handle here
        $this->outputFile = $fileHandle;

        return $this->send($request);
    }

}

?>